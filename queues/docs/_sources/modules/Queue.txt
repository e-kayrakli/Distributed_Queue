.. default-domain:: chpl

.. module:: Queue

Queue
=====
**Usage**

.. code-block:: chapel

   use Queue;

.. class:: Queue

   
   A data structure that allows for parallel-safe storage of elements. This Queue offers
   two variants: A FIFO Queue, which is the typical First-In-First-Out ordering as to
   be expected of a Queue, and the second being a 'Work' Queue, which does not impose
   any ordering whatsoever and aims to satiate the desire for high performance. Furthermore,
   we offer two further variants for each: a local version that is optimized for a single locale,
   and a distributed version that is optimized for multiple locales.


   .. attribute:: type eltType

      
      The type of the element.
      

   .. method:: proc enqueue(elts: eltType ...?nElts): (bool, int)

      
      Adds all elements to the queue, if successful. Elements are added in the
      order they are passed.
      
      If the queue is unbounded, it will always succeed with concatenation,
      but if the queue is bounded it may return false if not enough space is
      available.
      
      :arg elts: Tuple of elements
      :type elts: :type:`eltType`
      :returns: If the enqueue is successful, and how many elements are added.
      :rtype: :type:`(bool, int)`
      

   .. method:: proc enqueue(elts: [?n] eltType): (bool, int)

      
      Adds all elements to the queue. Elements are added in the order they in the array.
      See the first :proc:`enqueue` for more details.
      
      :returns: If the enqueue is successful, and how many elements are added.
      :rtype: (bool, int)
      

   .. method:: proc enqueue(queue: Queue(eltType)): bool

      
      Adds all elements to the queue. Elements are added in a more optimized way
      depending on the underlying type of the queue, and maintain :attr:`this` ordering.
      See the first :proc:`enqueue` for more details.
      
      :returns: If the enqueue is successful, and how many elements are added.
      :rtype: (bool, int)
      

   .. method:: proc enqueue(iterObj): bool

      
      Adds all elements yielded by the `iterObj`. In the case where not all
      elements can be added, then it is up to the user to be able to 'replay'
      elements not consumed and dropped. Elements are added in the order they are
      yielded. See the first :proc:`enqueue` for more details.
      
      :returns: If the enqueue is successful, and how many elements are added.
      :rtype: (bool, int)
      

   .. method:: proc dequeue(): (bool, eltType)

      
      Remove an element from thr queue.
      
      :returns: If the queue is not empty and the item taken if any.
      :rtype: (bool, eltType)
      

   .. method:: proc dequeue(nElems): (int, AppendExpr.Call08)

      
      Remove at most `nElems` elements from the queue.
      
      :returns: If the queue is not empty and an array of items taken, if any.
      :rtype: (bool, [?n] eltType)
      

   .. method:: proc freeze(): bool

      
      Freezes the queue, making it immutable, if supported.
      
      :returns: If it is a supported operation.
      :rtype: bool
      

   .. method:: proc unfreeze(): bool

      
      Unfreezes the queue, making it mutable, if supported.
      
      :returns: If it is a supported operation.
      :rtype: bool
      

   .. method:: proc +=(elt: eltType ...?nElts): bool

      
      Alias for enqueue.
      

   .. method:: proc +=(queue: Queue(eltType))

      
      Alias for enqueue.
      

   .. method:: proc +(elt: eltType ...?nElts)

      
      Feedback needed...
      

   .. method:: proc +(queue: Queue(eltType))

      
      Feedback needed...
      

   .. itermethod:: iter these()

      
      Iterates over all elements in the queue. If the queue is frozen, then iteration
      is read-only in that it will iterate over all elements without consuming them;
      a normal iteration is equivalent to a more optimized sequence of dequeue operation.
      

.. class:: QueueFactory

   .. method:: proc makeDistributedBoundedFIFO(type eltType, maxElems: uint = 0, targetLocales: [] locale = Locales): Queue(eltType)

      
      (WIP - In Planning)
      
      Creates a distributed bounded strict First-In-First-Out Queue.
      
      :type eltType: Element type
      
      :arg maxElems: Maximum number of elements in the queue; halts if value is 0.
      :type maxElems: uint
      
      :arg targetLocales: Locales to distribute across.
      :type targetLocales: [] locales
      

   .. method:: proc makeBoundedFIFO(type eltType, maxElems: uint = 0): Queue(eltType)

      
      (WIP - In Planning)
      
      Creates a local bounded strict First-In-First-Out Queue.
      
      :type eltType: Element type
      
      :arg maxElems: Maximum number of elements in the queue; halts if value is 0.
      :type maxElems: uint
      

   .. method:: proc makeDistributedUnboundedFIFO(type eltType, targetLocales: [] locale = Locales): Queue(eltType)

      
      Creates a distributed unbounded strict First-In-First-Out Queue.
      
      :type eltType: Element type
      
      :arg targetLocales: Locales to distribute across.
      :type targetLocales: [] locales
      

   .. method:: proc makeUnboundedFIFO(type eltType): Queue(eltType)

      
      Creates a local unbounded strict First-In-First-Out Queue.
      
      :type eltType: Element type
      

   .. method:: proc makeDistributedWorkQueue(type eltType, targetLocales: [] locale = Locales): Queue(eltType)

      
      Creates a distributed work stealing unbounded queue.
      
      :type eltType: Element type
      
      :arg targetLocales: Locales to distribute across.
      :type targetLocales: [] locales
      

   .. method:: proc makeWorkQueue(type eltType): Queue(eltType)

      
      Creates a distributed work stealing unbounded queue.
      
      :type eltType: Element type
      
      :arg targetLocales: Locales to distribute across.
      :type targetLocales: [] locales
      

